      subroutine input1(zcharge,zfill,thisvol,inpstat,flipos,
     $     lnoncol,ltorque,lspdir,spinat,dspth,dspphi)
      implicit real*8 (a-h,o-z)
      include 'P1'
c
c=======================================================================
c
c     REVISION HISTORY:
c
c-----------------------------------------------------------------------
c
c     Add 1-2 of lines to the input file, after the
c      structure is read in, but before the scale factors
c     (1) A "logical" variable STRAIN (read in on the same line
c         as "label"), which, if true, will read the next line as
c         e1,e2,e3,e4,e5,e6, the strains needed for elastic constant
c         calculations
c     (2) A 20 character label, used to tag the output energy,
c         stored in the array "LABELS"
c
c                                  -mjm    15 Nov 1993
c
c-----------------------------------------------------------------------
c
c     Set up for easier phonon calculations.  For each structure,
c      start by reading the equilibrium atom locations.  Then
c      read a phonon wave vector, q(i), in reciprocal lattice
c      coordinates, a displacement wave vector, eps(i), in Cartesian
c      coordinates with the displacement in Bohr, and a phase
c      factor qphase.  The kth atom is the basis is thus displaced
c      to the point
c
c     b(i,k) = b_0(i,k) + eps(i) sin( q.b_0 + 2 Pi qphase )
c
c     Note that different atom kinds can have different values of
c      eps and qphase, and we will dimension eps and qphase accordingly.
c
c     Phonon calculations are done if the variable "strain" has
c      the value "p" or "P"
c
c                                  -mjm     5 Jan 1994
c
c-----------------------------------------------------------------------
c
c     This is the part of the old "input1.f" which was inside
c      the jstruc do loop.
c                              -- mjm  19 Sept 1994
c
c-----------------------------------------------------------------------
c
c     Read in the formal valance charge on each atom
c                              -- mjm   3 Oct  1994
c
c     Optionally read in Hexagonal lattices as a special case
c                              -- mjm  15 Nov  1994
c
c-----------------------------------------------------------------------
c
c     Now this is all of the old "input1.f", except that
c      there is no structure number (jstruc, nstruc, nstrucd)
c      to worry about          -- mjm  15 Dec  1994
c
c-----------------------------------------------------------------------
c
c     Since we've redesigned the on-site terms in setup, we
c      don't need the "valance charge".  Also, put in a flag
c      (kind < 0) which allows us to input the basis vectors
c      in Cartesian coordinates on an atom-by-atom basis.
c                              -- mjm  15 Apr  1997
c
c-----------------------------------------------------------------------
c
c     If there is an error generated by this subroutine it is
c      reported as a value of inpstat > 0, and then the
c      subroutine exits.  This allows us to better handle
c      errors in parallel programs.
c                              -- mjm  24 Feb 1998
c
c-----------------------------------------------------------------------
c
c     VERSION 1.05
c
c     Some of the parameter file specific information has now been
c      moved to the parameter file and read by input.f.
c
c                              -- mjm   6 April 1998
c
c-----------------------------------------------------------------------
c
c     zfill is the number of electrons in the problem.  This is
c      determined from the nominal charges give in the parameter file
c      plus any additional charge given by zcharge.
c
c                              -- mjm   7 April 1998
c
c-----------------------------------------------------------------------
c
c     The primitive lattice vectors, plv, are now determined by the
c      routine setlat.f.  This allows us to specify the lattice
c      and lattice parameters by a only a few parameters, and allows
c      easy switching of input parameters, e.g. volume and c/a ratio.
c
c     In addition, the elastic strain input has also been moved to
c      setlat.f, and simplified considerably.  Set setlat.f for
c      details.
c
c     Some discussion of elastic strain inputs duplicates that
c      of setlat.f.  All elastic strains are performed in setlat.f.
c      Frozen phonon strains of the input basis vectors are still
c      applied in input1.
c                              -- mjm  20 April 1998
c
c-----------------------------------------------------------------------
c
c     Move a few more things around.  The "label" is now read in
c      with the "title" by the calling program.  The selection of
c      a frozen phonon input is now determined just before the input
c      of the basis atom positions.  The "strain" variable no longer
c      exists, we now simply read in lphonon.
c     Note that this removes most of the revisions in the first
c      block of this history, or at least moves them to other parts
c      of the program.
c                              -- mjm  22 April 1998
c
c-----------------------------------------------------------------------
c
c     Version 1.06:
c
c     Removed reference to jsover/jsreal, which are never used here.
c
c     Moved k-point generation parameters into 'P3'
c
c                              -- mjm 6 July  1998
c-----------------------------------------------------------------------
c
c     Version 1.10:
c
c     Revised the "phonon" mode.  Now we can shift any individual atom
c      away from its input position, using either Cartesian or lattice
c      coordinates.  This is useful if we want to move only a few atoms
c      away from equilibrium.  The old phonon operations described
c      above are now inoperative.
c
c                             -- mjm   3 Mar 1999
c-----------------------------------------------------------------------
c
c     Version 1.11
c
c     For some reason this routine did an 'include P3'.  There wasn't
c      any particular reason to do this, so it's gone now.
c                                                   --  mjm  27 Jul 1999
c-----------------------------------------------------------------------
c
c     Version 1.20
c
c     If the tight-binding parameters are magnetic (see input.f), then
c      allow for "spin flips."  That is, and the input for the atomic
c      positions is scanned to see if this particular atom is pointing
c      "up" or "down."  By default, the onsite part of spin 1 is
c      associated with up, and spin 2's onsites are associated with spin
c      down.  If an atom is pointed "up", or if "spinflip" is set to
c      .false., then the default situation holds.  If, however, an atom
c      is supposed to be "flipped," then the flipped atom uses the spin 2
c      onsites for "up" and spin 1 for "down."  In this way we can
c      generate an anti-ferromagnetic system.
c
c     Note that this necessitates a change in the input.  Because we
c      want to make the change transparent for non-magnetic calculations,
c      we let "spinflip" be read on the same line as lphonon.
c      "lphonon" and "spinflip" will now be read in as character
c      variables, with anything except "T" or "t" equated to false.
c      If "spinflip" is true, then the position input for each atom
c      must change.  Where before a line might have been
c
c      3  0.000  0.500  0.500  0 0 0
c
c      indicating that an atom of type 3 is located at lattice
c      coordinates (0,1/2,1/2) with no phase shift, if "spinflip" is
c      true then this line will change to
c
c      3  0.000  0.500  0.500  0 0 0 1
c
c      if the atom remains "up", and 
c
c      3  0.000  0.500  0.500  0 0 0 2
c
c      if the atom is now "down."  Note that "1" and "2" are used to
c       help with Fortran 77 free-format input.  These will be converted
c       to a logical array "flipos", where "flipos(i)" is true if
c       atom i is flipped.  Thus the default value of "flipos(i)" is
c       false for every atom.  Therefore we export "flipos" via the
c       argument list, and default to "flipos(i) = .false." in every
c       case, magnetic or not.
c
c     Note that setpar.f relies on "flipos(i) = .false." for all atoms
c     to signal the unpolarized or default magnetic case.  Because of
c     this, it is important that FLIPOS IS CHANGED ONLY IN THIS ROUTINE
c      (input1.f).                                    -- mjm 21 Dec 1999
c-----------------------------------------------------------------------
c
c     Version 1.30
c
c     This version implements non-collinear magnetism,
c      a la Pickett 1996.  input1.f must inform the rest of the code:
c
c     (1) If we are using ferromagnetic or "flipped" on-site parameters
c          as described in the Version 1.20 modifications,
c
c     (2) If we are instead assuming non-collinear spins, and
c
c     (3) If (2), get the orientation of every atom's spin relative to
c         the global axis.  Since there is no spin-orbit interaction,
c         this direction is uncoupled from the Cartesian axis of the
c         atoms.  This means that the total energy is invariant to
c         a global rotation of the spins.  A future version of the
c         code might be able to exploit that fact to reduce the
c         computational effort.
c
c     (4) If (2), optionally calculate the derivative of the total
c         energy with respect to each angle of each spin.  This is
c         signaled by the "ltorque" option.
c
c     NOTE: Two atoms with different spin directions cannot in
c      general be related by symmetry, and so must be treated as
c      different types of atoms when calculating the space group
c      and the k-point mesh.  This is especially important when
c      calculating the derivative with respect to angle.
c
c     ANOTHER NOTE:  input1.f will allow you to choose flipped
c      or non-collinear spins EVEN WHEN THE PARAMETERS ARE
c      PARAMAGNETIC (see input.f).  In the paramagnetic case spin
c      flipping will be ignored.  However, the main program,
c      static.f, will check to see that the parameters are compatable
c      with non-collinear magnetization (in which case jspin = 2 and
c      lnoncol = true).  If not, i.e., if jspin = 1 (set by input.f),
c      then the code will print a warning message to standard output
c      and SKOUT, and then set lnoncol to be false.
c
c     We'll signal the non-collinear state by a change in the input
c      of the variable "spinflip".  The new behavior of "spinflip"
c      is as follows:
c
c     If spinflip = "T" or "t", the behavior is the same as in
c      version 1.20.
c
c     If spinflip = "N" or "n", we assume non-collinear magnetization.
c      See below for the implications of this.
c
c     If spinflip = "D" or "d", assume non-collinear magnetization
c      AND calculate d E/d theta(i) and d E/d phi(i) for each
c      atom i using perturbation theory.  Export the flag "ltorque"
c      to tell the world of this.  Note that this option implies
c      non-collinear magnetization.
c
c     If spinflip is anything else, including whitespace, then we
c      assume a ferromagnetic calculation, with all atoms pointing
c      in the same direction.
c
c     Now in the non-collinear case (spinflip = "[Nn]"), we define
c      a logical variable, lnoncol, to be true.  Otherwise it is
c      false.  All of the "flipos" variables will remain false, as
c      they will be ignored by the program.  For each atom we will
c      read in the (theta,phi) coordinates showing the direction
c      of the spin, in degrees.  This will be converted into a
c      Cartesian unit vector,
c
c      spinat(1,i) = Sin(theta) Cos(phi)
c      spinat(2,i) = Sin(theta) Sin(phi)
c      spinat(3,i) = Cos(theta)
c
c     If ltorque is true, calculate dspth = d spinat/d theta
c      and dspphi = d spinat/d phi for each atom, and export the
c      resulting arrays.  Since the angles are expressed in degrees,
c      calculate the derivatives in units of energy/degree.
c
c     The "spinat" array, lnoncol, and ltorque will be exported to
c      the main program through the calling sequence, see the top
c      of this code.
c                                                  -- mjm  9-15 Aug 2000
c-----------------------------------------------------------------------
c
c     Version 1.31
c
c     We specify the direction of the spin of each atom in the input.
c      But this does not guarantee that we know the direction of each
c      spin in the output.  Here we turn on an option to determine the
c      "output spin direction" of each atom.  Note that at
c      self-consistency the input and output spin directions should be
c      aligned, so this is one way of determining the directions of
c      spins at a domain wall, or in a frustrated anti-ferromagnet.
c
c     If spinflip = "S" or "s", we set lspdir = true, and turn this
c      capability on.
c      Note that we could calculate torque and output magnetization
c       simultaneously.  At the moment, however, we'll leave keep
c       the calculations separate, i.e., you can only do one or the
c       other.  Since torque isn't computed as yet, this shouldn't
c       be much of a problem.
c                                                     -- mjm 26 Oct 2000
c=======================================================================
c
c
C*********************************************************
C   INPUT AND PRINTOUT OF CONTROL PARAMETERS AND DATA    *
C*********************************************************
C   HR,HI   : (COMPLEX) SLATER-KOSTER HAMILTONIAN        *
C   ZR,ZI   : (COMPLEX) EIGENVECTORS OF HAMILTONIAN      *
C   EN      : EIGENVALUES OF HAMILTONIAN                 *
C   KINDS   : NUMBER OF KINDS OF ATOMS                   *
C   NATOMS  : TOTAL NUMBER OF ATOMS IN THE UNIT CELL     *
C   KBAS(I) : NUMBER OF BASIS FUNCTIONS ON ATOM KIND     *
c              ( now set in parameter file)              *
C   PLV     : PRIMITIVE LATTICE VECTORS OF UNIT CELL     *
C              IN REAL COORDINATES (i.e. bohr)           *
C              (BUT READ IN IN CARTESIAN COORDINATES)    *
C              (i.e. PLVL*SCALE=PLV)                     *
C   PLVL    : PRIMITIVE LATTICE VECTORS OF UNIT CELL     *
C              IN CARTESIAN COORDINATES                  *
C   SCALE   : SCALE FACTORS FOR MULTIPLYING THE          *
C              CARTESIAN COORDINATES OF PLV AND POSN     *
C              (MAKES I/O EASY ESP. IN RECTANGULAR CELLS)*
C   ND1,2,3 : NUMBER OF NEIGHBORING UNIT CELL (+ & -)    *
C              SEARCHED FOR NEIGHBORS OF ATOMS IN CELL   *
C*********************************************************
C   POSN    : POSITIONS OF ATOMS IN THE UNIT CELL        *
C              IN CARTESIAN COORDINATES                  *
C   KKIND(I): KIND OF ATOM I                             *
C   KSK(I)  : BASE INDEX IN THE S-K MATRIX OF ATOM I,    *
C              WITH INDICES RUNNING FROM KSK(I)+1 TO     *
C              KSK(I)+KBAS(I)                            *
C   DNNSQ   : SQUARED DISTANCE BETWEEN NEIGHBORS (input.f)
C   PAR     : S-K PARAMETERS                             *
C   OVL     : OVERLAP PARAMETERS                         *
C*********************************************************
c
      common /parinfo/ valence(mkind),kinds,kbas(mkind)
      common /kstuff/ ksk(matom)
      common/latt1/plv(3,3)
c
c     MPTYPE was the neighbor number, now it is 1 for on-site,
c      and 2 for off-site
c     MPKIND is the number of integrals for each pair of kinds.
c      It will be 9 for on-site and 14 for off-site.
c
      common/codes/posn(matom,3),kkind(matom),natoms
c
cMPInote
c     The information previously held in displ as
c$$$      common/displ/nd1,nd2,nd3,kd1,kd2,kd3
c      will now be held in an array.  This will make it easier
c      to transport the information for search2 to see it
cend MPInote
      integer nkdarry(6)
      common/disply/ nkdarry
c
      common/struc/ nv
      common/fazon/posq(matom,3)
c
c     vlat temporarily holds the Lattice components of the vectors
c      when we've entered them in Cartesian coordinates (kkind(i)< 0)
c
      real*8 vlat(3)
c
c     bvec holds the reciprocal lattice vectors:
c
      real*8 bvec(3,3)
c
c     The "phonon mode" now (3/3/99) simply allows us to shift
c      individual atoms using either Cartesian or lattice
c      coordinates.
c
c     lphonon is true if we want to distort the atoms in a supercell
c      to mimic a phonon for a frozen phonon calculation.
c
      logical lphonon
c
c     As explained in the version 1.20 notes, "spinflip" is true if we
c      are going to allow spin flipping, and "flipos(i)" is true if atom
c      i is flipped.
c
      logical spinflip,flipos(matom)
c
c     As explained in the version 1.30 notes, "lnoncol" is true if
c      we are going to do a non-collinear spin calculation.  Note that
c      this overrides the "spinflip/flipos" operations of the last
c      line.
c
c     If lnoncol is true, ltorque allows us to find the derivatives
c      of the energy with respect to spin angles.
c      Alternatively, lspdir allows us to determine the direction
c      and magnetude of the output spin on each atom.
c
      logical lnoncol,ltorque,lspdir
c
c     lshift(j) is true if the jth atom is to be shifted (default false)
c     lcart(j) is true if the coordinates of the jth atom are entered
c      in Cartesian coordinates
c     ltemp is the temporary value of lcart
c
      logical lshift(matom),lcart(matom),ltemp
c
c     eps(i,j) is the ith Cartesian component of the
c      displacement of atom j.
c     epsl(i,j) are the lattice coordinates corresponding to eps
c     etemp(i) holds the coordinates until we figure out what to
c      do with them
c
      real*8 eps(3,matom),epsl(3,matom),etemp(3)
c
c     As seen if the Version 1.30 notes, if lnoncol is true we need
c      to specify the orientation of all of the atoms.  To do this
c      we read in (theta,psi) for each atom and convert it into the
c      unit vector spinat(i,iatom):
c
      real*8 spinat(3,matom)
c
c     If ltorque is on,
c
c     dspth (i,iatom) = d spinat(i,iatom)/ d theta(iatom), in Ry/degree
c     dspphi(i,iatom) = d spinat(i,iatom)/ d phi  (iatom), in Ry/degree
c
      real*8 dspth(3,matom), dspphi(3,matom)
c
c
c     Characters variables for reading in lphonon and spinflip:
c
      character*1 chr1,chr2
c
c-----------------------------------------------------------------------
c
c     Constants we'll need
c
      parameter (zero  = 0d0)
c$$$      parameter (two   = 2d0)
      parameter (pi    = 3.14159265358979323846d0)
c$$$      parameter (twopi = two*pi)
c
c     Convert degrees to radians:
c
      parameter (deg2rad = pi/180.0d0)
c
c     Needed character strings:
c
      character*1 tuc,tlc,nuc,nlc,duc,dlc,suc,slc
c
      parameter (tuc = "T")
      parameter (tlc = "t")
      parameter (nuc = "N")
      parameter (nlc = "n")
      parameter (duc = "D")
      parameter (dlc = "d")
      parameter (suc = "S")
      parameter (slc = "s")
c
c=======================================================================
c
c     Point all atoms up in spin space:
c
      do i = 1,matom
         flipos(i) = .false.
      end do
c
c     Apparently under this version of the compiler/OS, istlat is not
c      preset
c
      inpstat = 0
      istlat = 0
c
      call setlat(plv,thisvol,istlat)
c
c     If istlat <> 0, then an error has occured
c
      if(istlat.ne.0) then
         write(*,*) 'setlat error detected'
         inpstat = 1000 + istlat
         return
      end if
c
      read (10,*) natoms
      write( *,*) abs(natoms),' atoms in the calculation'
      write(15,*) abs(natoms),' atoms in the calculation'
c
c     nd1, nd2, and nd3 control the space search2 looks at to
c      find neighbors.  A more logical algorithm would determine
c      this by itself, so this may be deleted in future releases
c      of the code.
c
      read(10,*) nd1,nd2,nd3
c    
      kd1=2*nd1+1
      kd2=2*nd2+1
      kd3=2*nd3+1
cMPInote
c     stuff the appropriate values into the array
c
      nkdarry(1) = nd1
      nkdarry(2) = nd2
      nkdarry(3) = nd3
      nkdarry(4) = kd1
      nkdarry(5) = kd2
      nkdarry(6) = kd3
cend MPInote
c
      write(15,19) kinds,natoms
 19   format(5x,i2,' KINDS',8x,i4,' TOTAL ATOMS')
      write(15,11) ( i,(plv(i,j),j=1,3),i=1,3 )
 11   format(5X,'PRIMITIVE LATTICE VECTOR NO.',i2,3f10.6)
      write(15,22) nd1,nd2,nd3
 22   format(5x,'DISPLACEMENT INDICES',3i3)
      write(15,16) (kbas(i),i,i=1,kinds)
 16   format(5x,i2,' BASIS FUNCTIONS ON ATOM KIND',i2)
c
      write(15,*) 'Volume=',thisvol
c
c
c-----------------------------------------------------------------------
c
c     Read in lphonon and spinflip.  Note that chr1 and chr2 are one-bit
c      character variables, and that anything except "T" or "t" defaults
c      to false.
c
      read(10,'(2a1)',iostat=ioerr) chr1,chr2
      if(ioerr.ne.0) then
         write(*,*) 'Error reading lphonon or spinflip in input1.f'
         inpstat = 102
         return
      end if
c
      lphonon = (chr1.eq.tuc).or.(chr1.eq.tlc)
c
c     Version 1.20/1.30:  Check to see if we are flipping spins, or
c      if we are doing a non-collinear magnetization run, calculating
c      torques, or output spin direction:
c
      spinflip = (chr2.eq.tuc).or.(chr2.eq.tlc)
      lnoncol = (chr2.eq.nuc).or.(chr2.eq.nlc)
      ltorque = (chr2.eq.duc).or.(chr2.eq.dlc)
      lspdir  = (chr2.eq.suc).or.(chr2.eq.slc)
c
c     Either ltorque or lspdir implies lnoncol, but not visa versa:
c
      lnoncol = lnoncol.or.ltorque.or.lspdir
c
      if(lnoncol) then
         write( *,*) 'Non-Collinear Magnetization Calculation'
         write(15,*) 'Non-Collinear Magnetization Calculation'
      end if
c
      if(ltorque) then
         write( *,*) 'Derivatives wrt spin calculated in file SKDERIV'
         write(15,*) 'Derivatives wrt spin calculated in file SKDERIV'
      end if
c
      if(lspdir) then
         write( *,*) 'Final spin vectors in file SPNDIR'
         write(15,*) 'Final spin vectors in file SPNDIR'
      end if
c
c-----------------------------------------------------------------------
c
c     Phonon calculations
c        
c     To look a a frozen phonon, set the logical variable
c      lphonon to .true., then read in the displacement of each atom.
c      This is a substantial revision of the previous version of this
c      code, and isn't terribly easy to use, but it is the best
c      thing I can think of at the moment.
c
      if (lphonon) then
c
         write( *,*) 'Frozen phonon displacements enabled'
         write(15,*) 'Frozen phonon displacements enabled'
c
c        Default all atoms to no displacement:
c
         do i = 1,natoms
            lshift(i) = .false.
         end do
c
c        How many atoms are to be shifted?
c
         read(10,*) nshift
         if(nshift.gt.natoms) then
            write(*,*) 'input1:  phonon mode'
            write(*,*) 'You are trying to move more atoms than you have'
            inpstat = 103
            return
         end if
         write(*,'(''Enter the atom number,''/
     $        ''T for Cartesian or F for lattice coordinates,''/
     $        ''and the shift vector:'')')
         write(*,*) nshift,' atoms are displaced'
         write(15,*) nshift,' atoms are displaced'
c
c        For each shifted atom, get the atom number,
c         find out if the shift is Cartesian or lattice,
c         and get the vector
c
         do k = 1,nshift
            read(10,*) iatom,ltemp,(etemp(i),i=1,3)
ctemp
            write(*,*) iatom,ltemp,(etemp(i),i=1,3)
cend temp
c
c           Make sure we don't violate anything:
c
            if(iatom.gt.natoms) then
               write(*,*) 'input1:  phonon mode'
               write(*,*)
     $              'You are trying to move an atom you do not have'
               inpstat = 104
               return
            end if
            if(lshift(iatom)) then
               write(*,*) 'input1:  phonon mode'
               write(*,*) 'You are trying to shift atom ',iatom,
     $              ' twice'
               inpstat = 105
            end if
c
c           Get here?  Then things are probably OK:
c
            lshift(iatom) = .true.
            lcart(iatom) = ltemp
            if(ltemp) then
c
c              Save in Cartesian coordinates:
c
               do i = 1,3
                  eps(i,iatom) = etemp(i)
               end do
            else
c
c              Save in Lattice coordinates:
c
               do i = 1,3
                  epsl(i,iatom) = etemp(i)
               end do
            end if
         end do
      end if
c-----------------------------------------------------------------------
c
c     We may need the reciprocal lattice vectors.
c     These are stored in bvec without the 2 Pi factor.
c     Remember, in this routine, plv(i,j) is the jth Cartesian
c      component of the ith primitive vector of the current
c      structure
c
      do i = 1,3
         i1 = mod(i,3)+1
         i2 = mod(i1,3)+1
         do j = 1,3
            j1 = mod(j,3)+1
            j2 = mod(j1,3)+1
            bvec(i,j) = (plv(i1,j1)*plv(i2,j2)-
     $           plv(i1,j2)*plv(i2,j1))/thisvol
         end do
      end do
ctemp
      write(*,111) 'Primitive ',(i,(plv(i,j),j=1,3),i=1,3)
 111  format(/a10/(i5,3f15.9))
      write(*,111) 'Reciprocal',(i,(bvec(i,j),j=1,3),i=1,3)
cend temp
c
      if(lphonon) then
         do k = 1,natoms
            if(lshift(k)) then
               if(lcart(k)) then
c
c                 Convert Cartesian shifts to lattice coordinates:
c
                  do i = 1,3
                     sum = zero
                     do j = 1,3
                        sum = sum + eps(j,k)*bvec(i,j)
                     end do
                     epsl(i,k) = sum
                  end do
               else
c
c                 For completeness, convert lattice shifts to
c                  Cartesian coordinates
c
                  do i = 1,3
                     sum = zero
                     do j = 1,3
c
c                       Remember that the plv are reversed
c
                        sum = sum + epsl(j,k)*plv(i,j)
                     end do
                     eps(i,k) = sum
                  end do
               end if
            end if
         end do
ctemp
         write(*,'(''Atom shifts:'')')
         write(*,'(16x,''Cartesian'',27x,''Lattice'')')
         write(15,'(''Atom shifts:'')')
         write(15,'(16x,''Cartesian'',27x,''Lattice'')')
         do k = 1,natoms
            if(lshift(k)) then
               write(*,'(i5,3f10.7,5x,3f10.7)')
     $           k,(eps(i,k),i=1,3),(epsl(i,k),i=1,3)
               write(15,'(i5,3f10.7,5x,3f10.7)')
     $           k,(eps(i,k),i=1,3),(epsl(i,k),i=1,3)
            end if
         end do
cend temp
      end if
c
c -- End mjm --
c
      if(natoms.gt.matom) then
          write(0,*) 'input1:  natoms = ',natoms,' > matom = ',matom
          inpstat = 101
          return
      end if
c
c     Read atom types, positions, and, if spinflip is true,
c      the "direction" of magnetization for each atom.
c
      write(15,21)
      write(15,25)
 25   format(3x,'KIND',15x,'COORDINATES',16x,'AFTER RESCALING')
      kskct=0
c
c     Add up the secular equation size and total charge as we go:
c
      nv = 0
      zfill = zcharge
      do i=1,natoms
c
c        Three cases, depending upon the type of spin calculation
c         we are doing.
c
         if(lnoncol) then
c
c           If non-collinear magnetization, read in the angles
c            in degrees and convert to the appropriate unit vector:
c
            read (10,*) kkind(i),(posn(i,j),j=1,3),
     $           (posq(i,j),j=1,3),theta,phi
c
c           Convert to a Cartesian unit vector, remembering that
c            the angles are in degrees:
c
            spinat(1,i) = sin(deg2rad*theta)*cos(deg2rad*phi)
            spinat(2,i) = sin(deg2rad*theta)*sin(deg2rad*phi)
            spinat(3,i) = cos(deg2rad*theta)
c
c           If needed, calculate the derivatives wrt theta and phi,
c            in degrees:
c
            if(ltorque) then
               dspth(1,i) = deg2rad*
     $              cos(deg2rad*theta)*cos(deg2rad*phi)
               dspth(2,i) = deg2rad*
     $              cos(deg2rad*theta)*sin(deg2rad*phi)
               dspth(3,i) = -deg2rad*sin(deg2rad*theta)
c
               dspphi(1,i) = -deg2rad*
     $              sin(deg2rad*theta)*sin(deg2rad*phi)
               dspphi(2,i) = deg2rad*
     $              sin(deg2rad*theta)*cos(deg2rad*phi)
               dspphi(3,i) = zero
            end if
c
            write( *,'(''Atom '',i5,'' is aligned in direction'',
     $           2f12.5/''Unit vector '',3f12.5)')
     $           i,theta,phi,(spinat(k,i),k=1,3)
            write(15,'(''Atom '',i5,'' is aligned in direction'',
     $           2f12.5/''Unit vector '',3f12.5)')
     $           i,theta,phi,(spinat(k,i),k=1,3)
c
         else if(spinflip) then
c
c           If we are allowing spin flips, then check to see which
c            atoms are flipped:
c
            read (10,*) kkind(i),(posn(i,j),j=1,3),
     $           (posq(i,j),j=1,3),magdir
c
c           Anything except magdir = 2 is treated as the default
c            (spin up)
c
            flipos(i) = magdir.eq.2
         else
c
c           Otherwise, ignore the spin problem
c
            read (10,*) kkind(i),(posn(i,j),j=1,3),
     $           (posq(i,j),j=1,3)
         end if
c
c        New flag:  kkind(i) < 0 -> that the vector
c         posn(i,j) is the jth Cartesian coordinate of
c         the ith vector.  We'll need to change these back
c         into lattice coordinates:
c
         if(kkind(i).lt.0) then
c
c           Restore the atom type:
c
            kkind(i) = abs(kkind(i))
ctemp
            write(*,201) i,(posn(i,jlat),jlat=1,3)
 201        format(/'Position of atom ',i5,
     $           ' entered in Cartesian coordinates:'/
     $           3f18.10)
cend temp
c
            do ilat = 1,3
               sum = zero
               do jlat = 1,3
                  sum = sum + bvec(ilat,jlat)*posn(i,jlat)
               end do
               vlat(ilat) = sum
            end do
            do ilat = 1,3
               posn(i,ilat) = vlat(ilat)
            end do
ctemp
            write(*,202) (posn(i,jlat),jlat=1,3)
 202        format(/' and converted to in lattice coordinates:'/
     $           3f18.10)
cend temp
         end if
c
c        Update the secular equation size, the number of
c         electrons, and other pointers needed by setup and rotate.
c         Note that kkind(i) is now positive.
c
         nv = nv + kbas(kkind(i))
         zfill = zfill + valence(kkind(i))
         ksk(i)=kskct
         kskct=kskct+kbas(kkind(i))
c     
         if(lphonon) then
c
c           If required, displace this atom:
c
ctemp
            write(*,*) 'Atom ',i,' shift = ',lshift(i)
cend temp
            if(lshift(i)) then
               do j = 1,3
c
c                 Remember that posn has the atom first, then
c                  the vector index
c
                  posn(i,j) = posn(i,j) + epsl(j,i)
               end do
            end if
         end if
         write(15,12) kkind(i),
     $        (posn(i,j),j=1,3),(posq(i,j),j=1,3)
 12      format(i3,1x,3f10.7,1x,3f10.7,1x,3f10.7)
c
      end do
c
      if(spinflip) then
         do i = 1,natoms
            if(flipos(i)) then
               write( *,*) 'Atom ',i,' is spin down'
               write(15,*) 'Atom ',i,' is spin down'
            else
               write( *,*) 'Atom ',i,' is spin up'
               write(15,*) 'Atom ',i,' is spin up'
            end if
         end do
      end if
      write( *, *) 'Secular equation size = ',nv
      write(15, *) 'Secular equation size = ',nv
      write( *, *) zfill, ' electrons in the calculation'
      write(15, *) zfill, ' electrons in the calculation'
      write(15,17) (i,ksk(i),i=1,natoms)
 17   format( 4(4x,'ATOM',i3,' KSK =',i4) )
      write(15,21)
 21   format(1x,90(1h*))
c
      return
      end
