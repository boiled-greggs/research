      subroutine setham(jsover,ak,paros,hop,over,hmat,smat,lprint)
c
c********************************************************
c--->  SET UP THE COMPLEX SLATER-KOSTER MATRIX          *
c********************************************************
c
c     This code has been yanked from the original program setup.f.
c
c     setham.f is used to calculate the to determine the Hamiltonian
c      and (if jsover is true) overlap matricies from the neighbor lists
c      determined by search2.f, the Slater-Koster on-site, hopping and
c      overlap parameters found by setpar.f, and the k-point information
c      provided by bande.f.  The results are collected into the arrays
c      ham and (if jsover is true) smat.
c
c=======================================================================
c
c     REVISION HISTORY for setup.f:
c
c-----------------------------------------------------------------------
c
c REC 1/20/93
c scaling of parameters with simultaneous fitting of multiple structures
c
c-----------------------------------------------------------------------
c
c REC 6/3/93 uses list generated by search2.f
c
c-----------------------------------------------------------------------
c
c     Includes setup of perturbed Hamiltonian and overlap matrix
c      In this case, we'll use it to calculate the change in
c      eigenvalues as a function of volume.  That is, we're going
c      to calculate the pressure, as well as demonstrate that
c      we can do perturbation theory.
c                                                mjm -- 6 Sept 1994
c
c-----------------------------------------------------------------------
c
c     Note that the onsite parameters in PAR and OVL
c      should really be treated separately from the
c      hopping parameters.  For one thing, the onsites
c      never need jk1 <> jk2.
c                                                mjm -- 14 Sept 1994
c
c-----------------------------------------------------------------------
c
c     Pulled the perturbation initialization out of here
c      it will be installed in a subroutines of the form
c      "setxxx", where "xxx" describes the type of perturbation.
c      For example, setvol sets up the perturbations needed
c      to calculate the pressure.
c                                                mjm -- 19 Sept 1994
c
c-----------------------------------------------------------------------
c
c     Try to reduce the number of exponentials we need to calculate.
c      First, note that the onsite terms need to be calculated only
c      once per structure.  Then note that a similar thing applies
c      to the hopping and overlap parameters.
c                                                mjm -- 27 Sept 1994
c
c-----------------------------------------------------------------------
c
c     Modified to work with many atom types.  This includes the use
c      of a "valence" charge on each atom to help define the density.
c                                                mjm --  3 Oct  1994
c
c-----------------------------------------------------------------------
c
c     Include an "asymptotic" form of the on-site parameters for
c      rho^(2/3) < rhocut(i), i = s,p,d.  This allows the on-site
c      parameters to smoothly approach their atomic values for
c      densities smaller than those obtained in the original fit.
c                                                mjm --  6 Dec  1994
c
c-----------------------------------------------------------------------
c
c     Change from 3 parameters specifying the onsite term to
c      4 parameters                              mjm -- 14 Dec  1994
c
c-----------------------------------------------------------------------
c
c     Split d onsite terms into t2g and eg.  Not Kosher for arbitrarily
c      aligned systems, but it might work OK if we are careful.
c     Also make Slater-Koster prefactors quadratic in R.
c     Yes, we've done all of this before.
c                                                mjm -- 31 Oct  1995
c
c-----------------------------------------------------------------------
c
c     Now (hr,hi) and (sr,si) are stored in the complex arrays
c      hmat and smat.                            mjm --  5 Feb  1997
c
c-----------------------------------------------------------------------
c
c     Change the format of the on-site terms for binary systems.  Now
c      the on-site "densities" will be broken up by atom type, and
c      each atom type will have a separate contribution to the on-site
c      terms.  This eliminates the need for the "charges" zval.
c     Also reverse the indicies on par and ovl so that the mpkind
c      index is first, since this is the most rapidly varying.  This
c      will require a change in rotate.f.
c                                                mjm -- 15 Apr  1997
c
c-----------------------------------------------------------------------
c
c     search2 has been changed to eliminate the double counting of pairs.
c     This means that we'll have to make sure that the density
c      terms are incremented properly.
c                                                mjm --  2 May  1997
c
c-----------------------------------------------------------------------
c
c     Finally eliminated all reference to the "asymptotic" on-site
c      parameters.
c                                                mjm -- 23 Sept 1997
c
c-----------------------------------------------------------------------
c
c     If the parameter realov is true, then like atom overlap matricies
c      are constrained to have the correct behavior as R -> 0, i.e.
c      S_{l,l',m}(R) -> delta_{l,l'}
c
c     For these terms (and only these terms), the parametrization
c      is of the form
c
c     S(R) = [delta_{l,l'} + R( A + B R + C R^2)] Exp[-D^2 R]
c
c                                                mjm -- 25 Sept. 1997
c-----------------------------------------------------------------------
c
c     Version 1.05:
c
c     As part of the general upgrade, jsover is moved into the calling
c      parameters.  Remember that jsover = 1 for non-orthogonal
c      calculations, and 0 for orthogonal calculations.
c
c                                                mjm -- 20 April 1998
c-----------------------------------------------------------------------
c
c     Version 1.06:
c
c     jsover has been changed to a logical variable:
c        jsover = .true.  -> Non-orthogonal Hamiltonian (S <> identity)
c        jsover = .false. -> Orthogonal Hamiltonian (S = identity)
c
c                                                mjm --  6 July  1998
c
c     Change the name of the common block /overlap/ to /parcom/.  It now
c      includes the parametrization type variable nltype.
c     When nltype = 90000 use a special extended polynomial
c      representation for H_{ss sigma} and S_{ss sigma}.  This is
c      restricted to the H atom, so set all other Slater-Koster
c      parameters to 1.
c                                                mjm --  4 Aug   1998
c=======================================================================
c
c     Revision History for setham.f:
c
c     version 1.11:
c
c     Split off from setup.f.  Get k-point information, and the on-site,
c      Slater-Koster hopping, and (optional) overlap parameters from the
c      call statement, output the Hamiltonian and (optionally) overlap
c      matricies in the same way.
c
c     Note that the onsite parameters have been rewritten in a new form,
c      essentially independent of the way setpar.f does the
c      parametrization.
c
c                                                     mjm -- 30 Apr 1999
c=======================================================================
c
c     version 1.21:
c
c     Only print out the non-zero matrix elements     mjm --  7 Aug 2000
c=======================================================================
c
      implicit real*8 (a-h,o-z)
      include 'P1'
c
c=======================================================================
c
c     Input parameters:
c
c-----------------------------------------------------------------------
c
c     jsover is true if the calculation uses a non-orthogonal basis,
c      i.e., if we have to construct smat.  If jsover is false then
c      smat is just the identity matrix, which we will construct but
c      otherwise ignore.
c
      logical jsover
c
c-----------------------------------------------------------------------
c
c     ak is the current k-point
c
      real*8 ak(3)
c
c-----------------------------------------------------------------------
c
c     paros(1,iat) is the onsite "s" orbital for the iat-th atom.
c     2 = p, 3 = t2g, 4 = eg.
c
      real*8 paros(4,matom)
c
c-----------------------------------------------------------------------
c
c     hop(i,j) is the ith Slater-Koster Hamiltonian parameter
c      for the j-th pair in the list produced by search2.f.
c
      real*8 hop(mpkind,mpair)
c
c-----------------------------------------------------------------------
c
c     over is the corresponding quantity for the overlap matrix.
c      note that if jsover is false these are not calculated.  We
c      may split these off into a separate subroutine at a later point.
c
      real*8 over(mpkind,mpair)
c
c-----------------------------------------------------------------------
c
c     hmat and smat are the Hermitian Hamiltonian and Overlap
c      matrices, respectively, for the current k-point.  They
c      are expressed in packed form.
c
      complex*16 hmat(mh*(mh+1)/2),smat(mh*(mh+1)/2)
c
c-----------------------------------------------------------------------
c
c     lprint is true when we want the program to print certain
c      diagnostic information.
c
      logical lprint
c
c-----------------------------------------------------------------------
c
c     Common blocks:
c
      common /kstuff/ ksk(matom)
      common /codes/posn(matom,3),kkind(matom),natoms
      common /parinfo/ valence(mkind),kinds,kbas(mkind)
      common /types/ npkind(mptype)
      common /relat/dlv(3),jkind(2),jatm(2),kneigh
      common /pairs/tt_list(3,mpair),
     $     dlv_list(3,mpair),dist_list(mpair),
     $     screen_list(mpair),
     $     jkind_list(mpair,2),
     $     jatm_list(mpair,2),
     $     npairs
c
c     Only needed when we are printing the Hamiltonian.  Otherwise
c      it can be commented out.
c
      common/struc/ nv
c
c     Temporary array for reduced direction parameters:
c
      dimension tt(3)
c
c     Hopping and overlap parameters in form needed by rotate:
c
      real*8 par(mpkind,mkind,mkind),ovl(mpkind,mkind,mkind)
c
c=======================================================================
c
      parameter (zero = 0d0)
      parameter (one  = 1d0)
c
c=======================================================================
c
c     Zero out hmat and smat for safety:
c
c     Note that we only define the i < j triangle of the matricies:
c
      if(jsover) then
         do mij = 1,mh*(mh+1)/2
            hmat(mij)=dcmplx(zero,zero)
            smat(mij)=dcmplx(zero,zero)
         end do
      else
c
c        We only need hmat set up here:
c
         do mij = 1,mh*(mh+1)/2
            hmat(mij)=dcmplx(zero,zero)
         end do
      end if
c
c     setpar.f has set up everthing in terms of the interactions
c      between pairs
c
      do ipair=1,npairs
         jatm(1) =jatm_list(ipair,1)
         jatm(2) =jatm_list(ipair,2)
         jkind(1)=jkind_list(ipair,1)
         jkind(2)=jkind_list(ipair,2)
c$$$         dist=dist_list(ipair)
c
c        Properly order the atom types:
c
         jk1=min(jkind(1),jkind(2))
         jk2=max(jkind(1),jkind(2))
c
c        The exact path we take through this is determined by
c         the atom types:
c
         if(jk2.eq.jk1) then
c
c           4 onsite terms, cross on-site terms if kinds > 1,
c            and now terms/hopping-overlap ME
c
c           Like atoms:  npkind(2) parameters
c
            npk = npkind(2)
         else
c
c           Unlike atoms:  npkind(3) parameters
c
            npk = npkind(3)
         end if
c
c        Now use the predifined hop and (maybe) overlap parameters
c         to put everything into the order rotate expects to find:
c
         do j =1,npk
            par(j,jk2,jk1) = hop(j,ipair)
         end do
         if(jk1.ne.jk2)then
            do j=1,npkind(2)
               par(j,jk1,jk2)=par(j,jk2,jk1)
            end do
            par(2,jk1,jk2)=-par(11,jk2,jk1)
            par(5,jk1,jk2)= par(12,jk2,jk1)
            par(6,jk1,jk2)=-par(13,jk2,jk1)
            par(7,jk1,jk2)=-par(14,jk2,jk1)
         endif
         par(11,jk1,jk2)=-par(2,jk2,jk1)
         par(12,jk1,jk2)= par(5,jk2,jk1)
         par(13,jk1,jk2)=-par(6,jk2,jk1)
         par(14,jk1,jk2)=-par(7,jk2,jk1)
c
c        Non-Orthogonal Basis -- Setup Overlap Matrix
c
         if (jsover) then
c
c           The setup is identical to the one made for the
c            hopping term, except that these parameters are lower
c            on the list
c
            if(jk2.eq.jk1) then
               npk = npkind(2)
            else
               npk = npkind(3)
            end if
c
            do j=1,npk
               ovl(j,jk2,jk1) = over(j,ipair)
            end do
            if(jk1.ne.jk2)then
               do j=1,npkind(2)
                  ovl(j,jk1,jk2)=ovl(j,jk2,jk1)
               end do
               ovl(2,jk1,jk2)=-ovl(11,jk2,jk1)
               ovl(5,jk1,jk2)= ovl(12,jk2,jk1)
               ovl(6,jk1,jk2)=-ovl(13,jk2,jk1)
               ovl(7,jk1,jk2)=-ovl(14,jk2,jk1)
            endif
            ovl(11,jk1,jk2)=-ovl(2,jk2,jk1)
            ovl(12,jk1,jk2)= ovl(5,jk2,jk1)
            ovl(13,jk1,jk2)=-ovl(6,jk2,jk1)
            ovl(14,jk1,jk2)=-ovl(7,jk2,jk1)
         endif
c
c        Get the angles and distances right for this pair:
c
         do j=1,3
C........................................................
C--->  tt_list(j) ARE THE DIRECTION COSINES OF THE VECTOR
C--->  SEPARATING ATOM 2 FROM ATOM 1
C........................................................
c
            tt(j)=tt_list(j,ipair)
            dlv(j)=dlv_list(j,ipair)
         end do
c
         call rotate(tt(1),tt(2),tt(3),ak,par,ovl,hmat,
     $        jsover,smat,ksk,kbas)
c
      end do
c
c     On-site terms
c
c     Now add the on-site terms to this specific Hamiltonian
c
      do iat = 1,natoms
         jkind(1)=kkind(iat)
         jkind(2)=kkind(iat)
         jatm(1)=iat
         jatm(2)=iat
c
c        In older versions of the code, rotate was called to
c         set up the on-site terms.  Instead, we'll directly
c         include that portion of rotate in this code.
c
         kk=ksk(jatm(1))
         kb = kbas(jkind(1))
c
c        S states
c
         if(kb.gt.0) then
            kkj = kk + 1
            hmat(kkj*(kkj+1)/2) = hmat(kkj*(kkj+1)/2) +
     $           dcmplx(paros(1,iat),zero)
c
c           P states
c
            do j = 2,min(4,kb)
               kkj = kk + j
               hmat(kkj*(kkj+1)/2) = hmat(kkj*(kkj+1)/2) +
     $              dcmplx(paros(2,iat),zero)
            end do
c
c           D-t2g states
c
            do j = 5,min(7,kb)
               kkj = kk + j
               hmat(kkj*(kkj+1)/2) = hmat(kkj*(kkj+1)/2) +
     $              dcmplx(paros(3,iat),zero)
            end do
c
c           D-eg states
c
            do j = 8,min(9,kb)
               kkj = kk + j
               hmat(kkj*(kkj+1)/2) = hmat(kkj*(kkj+1)/2) +
     $              dcmplx(paros(4,iat),zero)
            end do
         end if
         if(jsover) then
c
c           Note that the overlap onsites are always unity:
c
            do j = 1,kb
               kkj = kk+j
               smat(kkj*(kkj+1)/2)=smat(kkj*(kkj+1)/2) +
     $              dcmplx(one,zero)
            end do
         end if
      end do
c
ctemp
C.......................................................
C--->  PRINTOUT OF HAMILTONIAN AND OVERLAP MATRICES
C.......................................................
c
      if(lprint) then
c
c        Only print out
         write(15,'(/''Secular equation dimension = '',i10)') nv
c     
         if(jsover) then
c
c           Print Hamiltonian and overlap on same line:
c
            write(15,'(/18x,''Hamiltonian Matrix'',17x,
     $           ''Overlap Matrix'')')
            i = 0
            do l1 = 1,nv
               do l2 = 1,l1
                  i = i + 1
                  if(abs(dreal(hmat(i)))+abs(dimag(hmat(i)))+
     $               abs(dreal(smat(i)))+abs(dimag(smat(i))).gt.
     $                 1d-10) write(15,'(3i6,2f15.10,5x,2f15.10)')
     $                 i,l1,l2,hmat(i),smat(i)
               end do
            end do
         else
c
c           Hamiltonian only
c
            write(15,'(/''Hamiltonian'')')
            i = 0
            do l1 = 1,nv
               do l2 = 1,l1
                  i = i + 1
                  if(abs(dreal(hmat(i)))+abs(dimag(hmat(i))).gt.
     $                 1d-10) write(15,51) i,l1,l2,hmat(i)
 51               format(3i6,2f15.10)
               end do
            end do
         end if
      end if
cend temp
      return
      end
